import React, { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Container,
  Typography,
  Stepper,
  Step,
  StepLabel,
  Button,
  Paper,
  TextField,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormGroup,
  FormControlLabel,
  Checkbox,
  Divider,
  Card,
  CardContent,
  CardActionArea,
  ToggleButton,
  ToggleButtonGroup,
  Alert,
  Chip,
  Slider,
  Snackbar,
  IconButton,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { PickersDay } from '@mui/x-date-pickers/PickersDay';
import { 
  ArrowBack as ArrowBackIcon, 
  ArrowForward as ArrowForwardIcon, 
  Event as EventIcon,
  Save as SaveIcon,
  Close as CloseIcon,
  ChevronLeft as ChevronLeftIcon,
  ChevronRight as ChevronRightIcon
} from '@mui/icons-material';
import { format, addDays, isAfter, isBefore, isEqual, parseISO, isSameDay, addMonths, subMonths, startOfMonth, getMonth, getYear } from 'date-fns';
import Layout from '../components/Layout';
import ServiceCard from '../components/ServiceCard';
import { venues, djs, cateringServices } from '../data/mockData';

// Define steps for the event creation process
const steps = ['Select Dates', 'Choose Venue', 'Select DJ', 'Add Catering', 'Confirm'];

// Define recommended combinations type
interface RecommendedCombination {
  id: string;
  name: string;
  description: string;
  venueId: string;
  djId: string;
  cateringId: string;
  tags: string[];
}

// Define recommended combinations
const recommendedCombinations: RecommendedCombination[] = [
  {
    id: 'elegant-wedding',
    name: 'Elegant Wedding Package',
    description: 'Perfect for upscale weddings with a sophisticated atmosphere',
    venueId: 'venue1', // Skyline Terrace
    djId: 'dj2', // DJ Harmony
    cateringId: 'catering1', // Gourmet Delights
    tags: ['wedding', 'elegant', 'upscale']
  },
  {
    id: 'corporate-event',
    name: 'Corporate Event Package',
    description: 'Ideal for professional business events and conferences',
    venueId: 'venue3', // Grand Ballroom
    djId: 'dj4', // DJ Pulse
    cateringId: 'catering3', // Fusion Flavors
    tags: ['corporate', 'business', 'professional']
  },
  {
    id: 'birthday-bash',
    name: 'Birthday Celebration Package',
    description: 'Fun and festive setup for birthday parties of all ages',
    venueId: 'venue2', // Beach Club
    djId: 'dj1', // DJ Beats
    cateringId: 'catering2', // Taste of Italy
    tags: ['birthday', 'celebration', 'party']
  },
  {
    id: 'casual-gathering',
    name: 'Casual Gathering Package',
    description: 'Relaxed atmosphere for friendly get-togethers and reunions',
    venueId: 'venue4', // Garden Pavilion
    djId: 'dj3', // DJ Groove
    cateringId: 'catering4', // Street Food Sensations
    tags: ['casual', 'relaxed', 'friends']
  }
];

const CreateEventPage: React.FC = () => {
  const navigate = useNavigate();
  const [activeStep, setActiveStep] = useState(0);
  
  // Add state for snackbar and dialog
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [saveDialogOpen, setSaveDialogOpen] = useState(false);
  const [draftName, setDraftName] = useState('');
  
  // State for form data
  const [eventData, setEventData] = useState({
    name: '',
    date: null as Date | null,
    dateRange: {
      start: null as Date | null,
      end: null as Date | null
    },
    selectedDates: [] as Date[],
    isMultiDay: false,
    isMultiSelect: false,
    isPublic: false,
    venueId: '',
    djId: '',
    cateringId: '',
    attendees: 50,
  });
  
  // State for available services based on date selection
  const [availableVenues, setAvailableVenues] = useState(venues);
  const [availableDJs, setAvailableDJs] = useState(djs);
  const [availableCaterers, setAvailableCaterers] = useState(cateringServices);
  
  // Add new state for filter-first approach
  const [venueFilters, setVenueFilters] = useState({
    types: [] as string[],
    maxPrice: 3000,
    styles: [] as string[]
  });

  const [djFilters, setDjFilters] = useState({
    genres: [] as string[],
    maxPrice: 1000
  });

  const [cateringFilters, setCateringFilters] = useState({
    cuisineTypes: [] as string[],
    maxPrice: 100
  });
  
  // Add state for available dates
  const [availableDates, setAvailableDates] = useState<Date[]>([]);
  
  // Add state for showing recommendations
  const [showRecommendations, setShowRecommendations] = useState(false);
  
  // Add state for calendar navigation
  const [calendarDate, setCalendarDate] = useState(new Date());
  
  // Load saved draft if available
  useEffect(() => {
    const savedDraft = localStorage.getItem('eventDraft');
    if (savedDraft) {
      try {
        const parsedDraft = JSON.parse(savedDraft);
        
        // Convert string dates back to Date objects
        if (parsedDraft.date) {
          parsedDraft.date = new Date(parsedDraft.date);
        }
        
        if (parsedDraft.dateRange.start) {
          parsedDraft.dateRange.start = new Date(parsedDraft.dateRange.start);
        }
        
        if (parsedDraft.dateRange.end) {
          parsedDraft.dateRange.end = new Date(parsedDraft.dateRange.end);
        }
        
        setEventData(parsedDraft);
        setSnackbarMessage('Draft loaded successfully');
        setSnackbarOpen(true);
      } catch (error) {
        console.error('Error loading draft:', error);
      }
    }
  }, []);
  
  // Update mock data to use current dates
  useEffect(() => {
    // Function to update dates in mock data to be from current day onwards
    const updateMockDataDates = () => {
      const today = new Date();
      
      // Helper function to create a date string in the format 'YYYY-MM-DD'
      const createDateString = (date: Date) => {
        return format(date, 'yyyy-MM-dd');
      };
      
      // Generate random dates from today onwards for each service
      const generateRandomDates = (count: number) => {
        const dates: string[] = [];
        for (let i = 0; i < count; i++) {
          // Random day between 0 and 180 days from today
          const randomDaysToAdd = Math.floor(Math.random() * 180);
          const randomDate = new Date(today);
          randomDate.setDate(today.getDate() + randomDaysToAdd);
          
          dates.push(createDateString(randomDate));
        }
        return dates;
      };
      
      // Update venues availability
      venues.forEach(venue => {
        venue.availability = generateRandomDates(30);
      });
      
      // Update DJs availability
      djs.forEach(dj => {
        dj.availability = generateRandomDates(30);
      });
      
      // Update catering services availability
      cateringServices.forEach(caterer => {
        caterer.availability = generateRandomDates(30);
      });
      
      // Refresh available services
      checkDateAvailability();
    };
    
    updateMockDataDates();
  }, []);
  
  // Update available services when date selection changes
  useEffect(() => {
    if (eventData.isMultiDay && eventData.dateRange.start && eventData.dateRange.end) {
      // Filter services based on date range
      filterServicesForDateRange(eventData.dateRange.start, eventData.dateRange.end);
    } else if (!eventData.isMultiDay && eventData.date) {
      // Filter services based on single date
      filterServicesForSingleDate(eventData.date);
    }
  }, [eventData.date, eventData.dateRange.start, eventData.dateRange.end, eventData.isMultiDay]);
  
  // Filter services for a single date
  const filterServicesForSingleDate = (date: Date) => {
    const dateString = format(date, 'yyyy-MM-dd');
    
    // Filter venues
    const filteredVenues = venues.filter(venue => 
      venue.availability.includes(dateString)
    );
    setAvailableVenues(filteredVenues);
    
    // Filter DJs
    const filteredDJs = djs.filter(dj => 
      dj.availability.includes(dateString)
    );
    setAvailableDJs(filteredDJs);
    
    // Filter caterers
    const filteredCaterers = cateringServices.filter(caterer => 
      caterer.availability.includes(dateString)
    );
    setAvailableCaterers(filteredCaterers);
  };
  
  // Filter services for a date range
  const filterServicesForDateRange = (startDate: Date, endDate: Date) => {
    // Generate array of dates in the range
    const dateRange: string[] = [];
    let currentDate = startDate;
    
    while (isBefore(currentDate, endDate) || isEqual(currentDate, endDate)) {
      dateRange.push(format(currentDate, 'yyyy-MM-dd'));
      currentDate = addDays(currentDate, 1);
    }
    
    // Filter venues available for ANY date in the range (not ALL dates)
    const filteredVenues = venues.filter(venue => 
      dateRange.some(date => venue.availability.includes(date))
    );
    setAvailableVenues(filteredVenues);
    
    // Filter DJs available for ANY date in the range
    const filteredDJs = djs.filter(dj => 
      dateRange.some(date => dj.availability.includes(date))
    );
    setAvailableDJs(filteredDJs);
    
    // Filter caterers available for ANY date in the range
    const filteredCaterers = cateringServices.filter(caterer => 
      dateRange.some(date => caterer.availability.includes(date))
    );
    setAvailableCaterers(filteredCaterers);
  };
  
  // Handle next step
  const handleNext = () => {
    setActiveStep((prevActiveStep) => prevActiveStep + 1);
  };
  
  // Handle back step
  const handleBack = () => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  };
  
  // Handle form input changes
  const handleChange = (field: string, value: any) => {
    setEventData({
      ...eventData,
      [field]: value,
    });
  };
  
  // Handle date type toggle
  const handleDateTypeChange = (
    event: React.MouseEvent<HTMLElement>,
    newDateType: boolean,
  ) => {
    if (newDateType !== null) {
      setEventData({
        ...eventData,
        isMultiDay: newDateType,
      });
    }
  };
  
  // Handle service selection
  const handleServiceSelect = (type: 'venue' | 'dj' | 'catering', id: string) => {
    const fieldMap = {
      venue: 'venueId',
      dj: 'djId',
      catering: 'cateringId',
    };
    
    handleChange(fieldMap[type], id);
  };
  
  // Handle date selection in multi-select mode
  const handleDateSelection = (date: Date) => {
    if (eventData.isMultiSelect) {
      // In multi-select mode, toggle individual dates
      const dateString = format(date, 'yyyy-MM-dd');
      const dateExists = eventData.selectedDates.some(d => format(d, 'yyyy-MM-dd') === dateString);
      
      if (dateExists) {
        // Remove date if already selected
        setEventData({
          ...eventData,
          selectedDates: eventData.selectedDates.filter(d => format(d, 'yyyy-MM-dd') !== dateString)
        });
      } else {
        // Add date if not already selected
        setEventData({
          ...eventData,
          selectedDates: [...eventData.selectedDates, date]
        });
      }
    } else if (eventData.isMultiDay) {
      // In range mode, handle range selection
      if (!eventData.dateRange.start || (eventData.dateRange.start && eventData.dateRange.end)) {
        // Start a new range
        setEventData({
          ...eventData,
          dateRange: { 
            start: date, 
            end: null 
          }
        });
      } else {
        // Complete the range
        const start = eventData.dateRange.start;
        if (date < start!) {
          // If clicked date is before start, swap them
          setEventData({
            ...eventData,
            dateRange: { 
              start: date, 
              end: start 
            }
          });
        } else {
          setEventData({
            ...eventData,
            dateRange: { 
              start: start, 
              end: date 
            }
          });
        }
      }
    } else {
      // Single date selection
      setEventData({
        ...eventData,
        date: date
      });
    }
  };
  
  // Handle selection mode toggle
  const handleSelectionModeChange = (
    event: React.MouseEvent<HTMLElement>,
    newSelectionMode: string,
  ) => {
    if (newSelectionMode === null) return;
    
    const isMultiDay = newSelectionMode === 'range';
    const isMultiSelect = newSelectionMode === 'multiple';
    
    setEventData({
      ...eventData,
      isMultiDay,
      isMultiSelect,
      // Reset date selections when changing modes
      date: null,
      dateRange: { start: null, end: null },
      selectedDates: []
    });
  };
  
  // Navigate to previous month in calendar
  const handlePrevMonth = () => {
    setCalendarDate(prevDate => subMonths(prevDate, 1));
  };
  
  // Navigate to next month in calendar
  const handleNextMonth = () => {
    setCalendarDate(prevDate => addMonths(prevDate, 1));
  };
  
  // Handle form submission
  const handleSubmit = () => {
    // Prepare the event data
    const submissionData = {
      ...eventData,
      // Format dates for submission
      date: eventData.date ? format(eventData.date, 'yyyy-MM-dd') : null,
      dateRange: {
        start: eventData.dateRange.start ? format(eventData.dateRange.start, 'yyyy-MM-dd') : null,
        end: eventData.dateRange.end ? format(eventData.dateRange.end, 'yyyy-MM-dd') : null,
      },
      selectedDates: eventData.selectedDates.map(date => format(date, 'yyyy-MM-dd'))
    };
    
    // In a real app, this would send the data to the backend
    console.log('Event data submitted:', submissionData);
    
    // Navigate to the My Events page
    navigate('/my-events');
  };
  
  // Apply filters to available services
  const applyFilters = () => {
    let filteredVenues = availableVenues;
    let filteredDJs = availableDJs;
    let filteredCaterers = availableCaterers;
    
    // Apply venue filters
    if (venueFilters.types.length > 0) {
      filteredVenues = filteredVenues.filter(venue => 
        venueFilters.types.includes(venue.type)
      );
    }
    
    if (venueFilters.styles.length > 0) {
      filteredVenues = filteredVenues.filter(venue => 
        venue.style.some(style => venueFilters.styles.includes(style))
      );
    }
    
    filteredVenues = filteredVenues.filter(venue => venue.price <= venueFilters.maxPrice);
    
    // Apply DJ filters
    if (djFilters.genres.length > 0) {
      filteredDJs = filteredDJs.filter(dj => 
        dj.genres.some(genre => djFilters.genres.includes(genre))
      );
    }
    
    filteredDJs = filteredDJs.filter(dj => dj.price <= djFilters.maxPrice);
    
    // Apply catering filters
    if (cateringFilters.cuisineTypes.length > 0) {
      filteredCaterers = filteredCaterers.filter(caterer => 
        caterer.cuisineType.some(cuisine => cateringFilters.cuisineTypes.includes(cuisine))
      );
    }
    
    filteredCaterers = filteredCaterers.filter(caterer => caterer.price <= cateringFilters.maxPrice);
    
    // Update available services with filtered results
    setAvailableVenues(filteredVenues);
    setAvailableDJs(filteredDJs);
    setAvailableCaterers(filteredCaterers);
  };

  // Handle filter changes
  const handleVenueFilterChange = (filter: string, value: any) => {
    setVenueFilters({
      ...venueFilters,
      [filter]: value
    });
  };

  const handleDjFilterChange = (filter: string, value: any) => {
    setDjFilters({
      ...djFilters,
      [filter]: value
    });
  };

  const handleCateringFilterChange = (filter: string, value: any) => {
    setCateringFilters({
      ...cateringFilters,
      [filter]: value
    });
  };
  
  // Add reset filter functions
  const resetVenueFilters = () => {
    setVenueFilters({
      types: [],
      maxPrice: 3000,
      styles: []
    });
  };
  
  const resetDjFilters = () => {
    setDjFilters({
      genres: [],
      maxPrice: 1000
    });
  };
  
  const resetCateringFilters = () => {
    setCateringFilters({
      cuisineTypes: [],
      maxPrice: 100
    });
  };
  
  const resetAllFilters = () => {
    resetVenueFilters();
    resetDjFilters();
    resetCateringFilters();
  };
  
  // Function to check if a date has matching options
  const checkDateAvailability = () => {
    // Get all unique dates from venues, DJs, and caterers
    const allDates = new Set<string>();
    
    // Apply filters to get filtered services
    let filteredVenues = venues;
    let filteredDJs = djs;
    let filteredCaterers = cateringServices;
    
    // Apply venue filters
    if (venueFilters.types.length > 0) {
      filteredVenues = filteredVenues.filter(venue => 
        venueFilters.types.includes(venue.type)
      );
    }
    
    if (venueFilters.styles.length > 0) {
      filteredVenues = filteredVenues.filter(venue => 
        venue.style.some(style => venueFilters.styles.includes(style))
      );
    }
    
    filteredVenues = filteredVenues.filter(venue => venue.price <= venueFilters.maxPrice);
    
    // Apply DJ filters
    if (djFilters.genres.length > 0) {
      filteredDJs = filteredDJs.filter(dj => 
        dj.genres.some(genre => djFilters.genres.includes(genre))
      );
    }
    
    filteredDJs = filteredDJs.filter(dj => dj.price <= djFilters.maxPrice);
    
    // Apply catering filters
    if (cateringFilters.cuisineTypes.length > 0) {
      filteredCaterers = filteredCaterers.filter(caterer => 
        caterer.cuisineType.some(cuisine => cateringFilters.cuisineTypes.includes(cuisine))
      );
    }
    
    filteredCaterers = filteredCaterers.filter(caterer => caterer.price <= cateringFilters.maxPrice);
    
    // Get all dates where at least one venue, one DJ, and one caterer are available
    const venueDates = new Set<string>();
    const djDates = new Set<string>();
    const catererDates = new Set<string>();
    
    filteredVenues.forEach(venue => {
      venue.availability.forEach(date => venueDates.add(date));
    });
    
    filteredDJs.forEach(dj => {
      dj.availability.forEach(date => djDates.add(date));
    });
    
    filteredCaterers.forEach(caterer => {
      caterer.availability.forEach(date => catererDates.add(date));
    });
    
    // Find dates that have at least one venue, one DJ, and one caterer available
    venueDates.forEach(date => {
      if (djDates.has(date) && catererDates.has(date)) {
        allDates.add(date);
      }
    });
    
    // Convert string dates to Date objects with proper error handling
    const availableDateObjects = Array.from(allDates).map(dateStr => {
      try {
        const parsedDate = new Date(dateStr);
        // Check if the date is valid
        if (isNaN(parsedDate.getTime())) {
          console.warn(`Invalid date string: ${dateStr}`);
          return null;
        }
        return parsedDate;
      } catch (error) {
        console.error(`Error parsing date: ${dateStr}`, error);
        return null;
      }
    }).filter((date): date is Date => date !== null); // Filter out null values and type assertion
    
    setAvailableDates(availableDateObjects);
  };
  
  // Call checkDateAvailability when filters change
  useEffect(() => {
    checkDateAvailability();
    applyFilters(); // Automatically apply filters when they change
  }, [venueFilters, djFilters, cateringFilters]);
  
  // Handle saving draft
  const handleSaveDraft = () => {
    setSaveDialogOpen(true);
  };
  
  const confirmSaveDraft = () => {
    try {
      localStorage.setItem('eventDraft', JSON.stringify(eventData));
      localStorage.setItem('eventDraftName', draftName || 'Untitled Event');
      setSnackbarMessage('Draft saved successfully');
      setSnackbarOpen(true);
      setSaveDialogOpen(false);
    } catch (error) {
      console.error('Error saving draft:', error);
      setSnackbarMessage('Error saving draft');
      setSnackbarOpen(true);
    }
  };
  
  const handleSnackbarClose = () => {
    setSnackbarOpen(false);
  };
  
  // Filter recommendations based on current filters
  const filteredRecommendations = useMemo(() => {
    return recommendedCombinations.filter(combo => {
      const venue = venues.find(v => v.id === combo.venueId);
      const dj = djs.find(d => d.id === combo.djId);
      const catering = cateringServices.find(c => c.id === combo.cateringId);
      
      // Check if all services exist
      if (!venue || !dj || !catering) return false;
      
      // Check venue filters
      if (venueFilters.types.length > 0 && !venueFilters.types.includes(venue.type)) return false;
      if (venueFilters.styles.length > 0 && !venue.style.some(style => venueFilters.styles.includes(style))) return false;
      if (venue.price > venueFilters.maxPrice) return false;
      
      // Check DJ filters
      if (djFilters.genres.length > 0 && !dj.genres.some(genre => djFilters.genres.includes(genre))) return false;
      if (dj.price > djFilters.maxPrice) return false;
      
      // Check catering filters
      if (cateringFilters.cuisineTypes.length > 0 && !catering.cuisineType.some(cuisine => cateringFilters.cuisineTypes.includes(cuisine))) return false;
      if (catering.price > cateringFilters.maxPrice) return false;
      
      return true;
    });
  }, [venueFilters, djFilters, cateringFilters]);
  
  // Apply a recommended combination
  const applyRecommendation = (combo: RecommendedCombination) => {
    setEventData({
      ...eventData,
      venueId: combo.venueId,
      djId: combo.djId,
      cateringId: combo.cateringId
    });
    
    setSnackbarMessage(`Applied "${combo.name}" package`);
    setSnackbarOpen(true);
    setShowRecommendations(false);
  };
  
  // Render different step content based on active step
  const getStepContent = (step: number) => {
    switch (step) {
      case 0: // Date and filter selection
        return (
          <Box sx={{ mt: 4 }}>
            <Typography variant="h6" gutterBottom>
              Plan Your Event
            </Typography>
            
            <Paper sx={{ p: 3, mb: 3 }}>
              <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                Event Details
              </Typography>
              
              <TextField
                fullWidth
                label="Event Name"
                value={eventData.name}
                onChange={(e) => handleChange('name', e.target.value)}
                margin="normal"
              />
              
              <TextField
                fullWidth
                label="Expected Attendees"
                type="number"
                value={eventData.attendees}
                onChange={(e) => handleChange('attendees', parseInt(e.target.value))}
                margin="normal"
              />
              
              <FormGroup sx={{ mt: 2 }}>
                <FormControlLabel 
                  control={
                    <Checkbox 
                      checked={eventData.isPublic} 
                      onChange={(e) => handleChange('isPublic', e.target.checked)} 
                    />
                  } 
                  label="Make this event public (visible in featured events)" 
                />
              </FormGroup>
            </Paper>
            
            {/* Recommended Packages Section */}
            <Paper sx={{ p: 3, mb: 3 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="subtitle1" fontWeight="medium">
                  Recommended Packages
                </Typography>
                <Button 
                  size="small" 
                  onClick={() => setShowRecommendations(!showRecommendations)}
                >
                  {showRecommendations ? 'Hide Packages' : 'Show Packages'}
                </Button>
              </Box>
              
              {showRecommendations && (
                <Box sx={{ mt: 2 }}>
                  {filteredRecommendations.length > 0 ? (
                    <Grid container spacing={2}>
                      {filteredRecommendations.map((combo) => {
                        const venue = venues.find(v => v.id === combo.venueId);
                        const dj = djs.find(d => d.id === combo.djId);
                        const catering = cateringServices.find(c => c.id === combo.cateringId);
                        
                        if (!venue || !dj || !catering) return null;
                        
                        const packagePrice = venue.price + dj.price + (catering.price * eventData.attendees);
                        
                        return (
                          <Grid item xs={12} sm={6} key={combo.id}>
                            <Card>
                              <CardContent>
                                <Typography variant="h6" gutterBottom>
                                  {combo.name}
                                </Typography>
                                <Typography variant="body2" color="text.secondary" paragraph>
                                  {combo.description}
                                </Typography>
                                <Typography variant="body2" gutterBottom>
                                  <strong>Venue:</strong> {venue.name}
                                </Typography>
                                <Typography variant="body2" gutterBottom>
                                  <strong>DJ:</strong> {dj.name}
                                </Typography>
                                <Typography variant="body2" gutterBottom>
                                  <strong>Catering:</strong> {catering.name}
                                </Typography>
                                <Typography variant="body1" fontWeight="bold" sx={{ mt: 1 }}>
                                  Package Price: ${packagePrice.toLocaleString()}
                                </Typography>
                                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 1 }}>
                                  {combo.tags.map((tag) => (
                                    <Chip key={tag} label={tag} size="small" />
                                  ))}
                                </Box>
                              </CardContent>
                              <CardActionArea onClick={() => applyRecommendation(combo)}>
                                <Box sx={{ p: 2, bgcolor: 'primary.main', color: 'white', textAlign: 'center' }}>
                                  Apply Package
                                </Box>
                              </CardActionArea>
                            </Card>
                          </Grid>
                        );
                      })}
                    </Grid>
                  ) : (
                    <Alert severity="info">
                      No recommended packages match your current filters. Try adjusting your preferences or create a custom combination.
                    </Alert>
                  )}
                </Box>
              )}
            </Paper>
            
            <Paper sx={{ p: 3, mb: 3 }}>
              <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                Date Selection
              </Typography>
              
              <ToggleButtonGroup
                value={eventData.isMultiSelect ? 'multiple' : (eventData.isMultiDay ? 'range' : 'single')}
                exclusive
                onChange={handleSelectionModeChange}
                aria-label="date selection mode"
                fullWidth
                sx={{ mb: 3 }}
              >
                <ToggleButton value="single" aria-label="single day">
                  Single Day
                </ToggleButton>
                <ToggleButton value="range" aria-label="date range">
                  Date Range
                </ToggleButton>
                <ToggleButton value="multiple" aria-label="multiple days">
                  Multiple Days
                </ToggleButton>
              </ToggleButtonGroup>
              
              <Box sx={{ mb: 2 }}>
                {eventData.isMultiSelect ? (
                  <Typography variant="subtitle2">
                    Select multiple individual dates (they don't have to be consecutive)
                  </Typography>
                ) : eventData.isMultiDay ? (
                  <Typography variant="subtitle2">
                    Select a start and end date for your event
                  </Typography>
                ) : (
                  <Typography variant="subtitle2">
                    Select a single date for your event
                  </Typography>
                )}
              </Box>
              
              {/* Date selection summary */}
              {eventData.isMultiSelect && eventData.selectedDates.length > 0 && (
                <Box sx={{ mt: 2, mb: 2, display: 'flex', alignItems: 'center' }}>
                  <EventIcon color="primary" sx={{ mr: 1 }} />
                  <Typography>
                    Selected {eventData.selectedDates.length} date{eventData.selectedDates.length > 1 ? 's' : ''}:
                    {' '}
                    {eventData.selectedDates
                      .sort((a, b) => a.getTime() - b.getTime())
                      .map(date => format(date, 'MMM d, yyyy'))
                      .join(', ')}
                  </Typography>
                </Box>
              )}
              
              {eventData.isMultiDay && eventData.dateRange.start && eventData.dateRange.end && (
                <Box sx={{ mt: 2, mb: 2, display: 'flex', alignItems: 'center' }}>
                  <EventIcon color="primary" sx={{ mr: 1 }} />
                  <Typography>
                    {format(eventData.dateRange.start, 'MMM d, yyyy')} - {format(eventData.dateRange.end, 'MMM d, yyyy')}
                    {' '}
                    ({Math.round((eventData.dateRange.end.getTime() - eventData.dateRange.start.getTime()) / (1000 * 60 * 60 * 24)) + 1} days)
                  </Typography>
                </Box>
              )}
              
              {!eventData.isMultiDay && !eventData.isMultiSelect && eventData.date && (
                <Box sx={{ mt: 2, mb: 2, display: 'flex', alignItems: 'center' }}>
                  <EventIcon color="primary" sx={{ mr: 1 }} />
                  <Typography>
                    {format(eventData.date, 'MMM d, yyyy')}
                  </Typography>
                </Box>
              )}
              
              <Box sx={{ mt: 3 }}>
                <Typography variant="subtitle2" gutterBottom>
                  Available Dates (based on your filters):
                </Typography>
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                  {availableDates.length > 0 ? (
                    availableDates
                      .sort((a, b) => a.getTime() - b.getTime())
                      .map((date, index) => {
                        // Check if this date is selected
                        const dateString = format(date, 'yyyy-MM-dd');
                        const isSelected = eventData.isMultiSelect 
                          ? eventData.selectedDates.some(d => format(d, 'yyyy-MM-dd') === dateString)
                          : eventData.isMultiDay 
                            ? (eventData.dateRange.start && eventData.dateRange.end && 
                               date >= eventData.dateRange.start && date <= eventData.dateRange.end)
                            : (eventData.date && format(eventData.date, 'yyyy-MM-dd') === dateString);
                        
                        return (
                          <Chip 
                            key={index} 
                            label={format(date, 'MMM d, yyyy')} 
                            color={isSelected ? "primary" : "success"}
                            variant={isSelected ? "filled" : "outlined"}
                            onClick={() => handleDateSelection(date)}
                            sx={{ cursor: 'pointer' }}
                          />
                        );
                      })
                  ) : (
                    <Typography color="text.secondary">
                      No dates available with current filters. Try adjusting your preferences.
                    </Typography>
                  )}
                </Box>
              </Box>
              
              <Box sx={{ mt: 4 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="subtitle2">
                    Calendar View:
                  </Typography>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <IconButton onClick={handlePrevMonth} size="small">
                      <ChevronLeftIcon />
                    </IconButton>
                    <Typography sx={{ mx: 1 }}>
                      {format(calendarDate, 'MMMM yyyy')}
                    </Typography>
                    <IconButton onClick={handleNextMonth} size="small">
                      <ChevronRightIcon />
                    </IconButton>
                  </Box>
                </Box>
                
                <Paper sx={{ p: 2, bgcolor: 'background.default' }}>
                  <Box sx={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: 1 }}>
                    {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                      <Box key={day} sx={{ textAlign: 'center', fontWeight: 'bold', p: 1 }}>
                        {day}
                      </Box>
                    ))}
                    
                    {(() => {
                      // Generate calendar for selected month
                      const currentMonth = getMonth(calendarDate);
                      const currentYear = getYear(calendarDate);
                      
                      // First day of the month
                      const firstDay = startOfMonth(calendarDate);
                      const startingDayOfWeek = firstDay.getDay();
                      
                      // Last day of the month
                      const lastDay = new Date(currentYear, currentMonth + 1, 0);
                      const daysInMonth = lastDay.getDate();
                      
                      // Generate calendar cells
                      const calendarCells = [];
                      
                      // Add empty cells for days before the first of the month
                      for (let i = 0; i < startingDayOfWeek; i++) {
                        calendarCells.push(
                          <Box key={`empty-${i}`} sx={{ p: 1, textAlign: 'center', color: 'text.disabled' }}></Box>
                        );
                      }
                      
                      // Add cells for each day of the month
                      for (let day = 1; day <= daysInMonth; day++) {
                        const date = new Date(currentYear, currentMonth, day);
                        const dateString = format(date, 'yyyy-MM-dd');
                        
                        // Check if this date is available
                        const isAvailable = availableDates.some(availableDate => 
                          format(availableDate, 'yyyy-MM-dd') === dateString
                        );
                        
                        // Check if this is today
                        const today = new Date();
                        const isToday = day === today.getDate() && 
                                        currentMonth === today.getMonth() && 
                                        currentYear === today.getFullYear();
                        
                        // Check if this date is in the past
                        const isPast = date < new Date(new Date().setHours(0, 0, 0, 0));
                        
                        // Check if this date is selected
                        const isSelected = eventData.isMultiSelect 
                          ? eventData.selectedDates.some(d => format(d, 'yyyy-MM-dd') === dateString)
                          : eventData.isMultiDay 
                            ? (eventData.dateRange.start && eventData.dateRange.end && 
                               date >= eventData.dateRange.start && date <= eventData.dateRange.end)
                            : (eventData.date && format(eventData.date, 'yyyy-MM-dd') === dateString);
                        
                        calendarCells.push(
                          <Box 
                            key={day} 
                            sx={{ 
                              p: 1, 
                              textAlign: 'center', 
                              borderRadius: 1,
                              border: isToday ? '2px solid' : '1px solid',
                              borderColor: isToday ? 'primary.main' : 'divider',
                              bgcolor: isSelected 
                                ? 'primary.main' 
                                : isAvailable 
                                  ? 'success.light' 
                                  : 'background.paper',
                              color: isSelected 
                                ? 'primary.contrastText' 
                                : isAvailable 
                                  ? 'success.contrastText' 
                                  : isPast
                                    ? 'text.disabled'
                                    : 'text.primary',
                              cursor: isPast ? 'not-allowed' : 'pointer',
                              opacity: isPast ? 0.5 : 1,
                              '&:hover': {
                                bgcolor: isPast 
                                  ? undefined 
                                  : isSelected 
                                    ? 'primary.dark' 
                                    : 'action.hover'
                              }
                            }}
                            onClick={() => {
                              if (!isPast) {
                                handleDateSelection(date);
                              }
                            }}
                          >
                            {day}
                          </Box>
                        );
                      }
                      
                      return calendarCells;
                    })()}
                  </Box>
                  
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Box sx={{ width: 16, height: 16, bgcolor: 'success.light', mr: 1, borderRadius: 1 }}></Box>
                      <Typography variant="body2">Available</Typography>
                    </Box>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Box sx={{ width: 16, height: 16, bgcolor: 'primary.main', mr: 1, borderRadius: 1 }}></Box>
                      <Typography variant="body2">Selected</Typography>
                    </Box>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Box sx={{ width: 16, height: 16, bgcolor: 'background.paper', border: '2px solid', borderColor: 'primary.main', mr: 1, borderRadius: 1 }}></Box>
                      <Typography variant="body2">Today</Typography>
                    </Box>
                  </Box>
                </Paper>
              </Box>
            </Paper>
            
            <Paper sx={{ p: 3, mb: 3 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="subtitle1" fontWeight="medium">
                  Venue Preferences
                </Typography>
                <Button 
                  size="small" 
                  onClick={resetVenueFilters}
                  startIcon={<ArrowBackIcon />}
                >
                  Reset Filters
                </Button>
              </Box>
              
              <FormControl fullWidth margin="normal">
                <InputLabel id="venue-types-label">Venue Type</InputLabel>
                <Select
                  labelId="venue-types-label"
                  multiple
                  value={venueFilters.types}
                  onChange={(e) => handleVenueFilterChange('types', e.target.value)}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {(selected as string[]).map((value) => (
                        <Chip key={value} label={value} />
                      ))}
                    </Box>
                  )}
                >
                  <MenuItem value="indoor">Indoor</MenuItem>
                  <MenuItem value="outdoor">Outdoor</MenuItem>
                  <MenuItem value="both">Both Indoor & Outdoor</MenuItem>
                </Select>
              </FormControl>
              
              <FormControl fullWidth margin="normal">
                <InputLabel id="venue-styles-label">Venue Style</InputLabel>
                <Select
                  labelId="venue-styles-label"
                  multiple
                  value={venueFilters.styles}
                  onChange={(e) => handleVenueFilterChange('styles', e.target.value)}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {(selected as string[]).map((value) => (
                        <Chip key={value} label={value} />
                      ))}
                    </Box>
                  )}
                >
                  {['rooftop', 'modern', 'elegant', 'classic', 'beach', 'villa', 'relaxed', 'rustic', 'industrial', 'garden'].map((style) => (
                    <MenuItem key={style} value={style}>
                      {style}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              
              <Box sx={{ mt: 3 }}>
                <Typography id="venue-price-slider" gutterBottom>
                  Maximum Venue Price: ${venueFilters.maxPrice}
                </Typography>
                <Slider
                  value={venueFilters.maxPrice}
                  onChange={(e, newValue) => handleVenueFilterChange('maxPrice', newValue)}
                  min={500}
                  max={5000}
                  step={100}
                  aria-labelledby="venue-price-slider"
                />
              </Box>
            </Paper>
            
            <Paper sx={{ p: 3, mb: 3 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="subtitle1" fontWeight="medium">
                  DJ Preferences
                </Typography>
                <Button 
                  size="small" 
                  onClick={resetDjFilters}
                  startIcon={<ArrowBackIcon />}
                >
                  Reset Filters
                </Button>
              </Box>
              
              <FormControl fullWidth margin="normal">
                <InputLabel id="dj-genres-label">Music Genres</InputLabel>
                <Select
                  labelId="dj-genres-label"
                  multiple
                  value={djFilters.genres}
                  onChange={(e) => handleDjFilterChange('genres', e.target.value)}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {(selected as string[]).map((value) => (
                        <Chip key={value} label={value} />
                      ))}
                    </Box>
                  )}
                >
                  {['House', 'Electronic', 'Pop', 'Hip Hop', 'R&B', 'Top 40', 'Latin', 'Reggaeton', 'Dance', 'Rock', 'Techno', 'Country'].map((genre) => (
                    <MenuItem key={genre} value={genre}>
                      {genre}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              
              <Box sx={{ mt: 3 }}>
                <Typography id="dj-price-slider" gutterBottom>
                  Maximum DJ Price: ${djFilters.maxPrice}
                </Typography>
                <Slider
                  value={djFilters.maxPrice}
                  onChange={(e, newValue) => handleDjFilterChange('maxPrice', newValue)}
                  min={300}
                  max={2000}
                  step={100}
                  aria-labelledby="dj-price-slider"
                />
              </Box>
            </Paper>
            
            <Paper sx={{ p: 3, mb: 3 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="subtitle1" fontWeight="medium">
                  Catering Preferences
                </Typography>
                <Button 
                  size="small" 
                  onClick={resetCateringFilters}
                  startIcon={<ArrowBackIcon />}
                >
                  Reset Filters
                </Button>
              </Box>
              
              <FormControl fullWidth margin="normal">
                <InputLabel id="cuisine-types-label">Cuisine Types</InputLabel>
                <Select
                  labelId="cuisine-types-label"
                  multiple
                  value={cateringFilters.cuisineTypes}
                  onChange={(e) => handleCateringFilterChange('cuisineTypes', e.target.value)}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {(selected as string[]).map((value) => (
                        <Chip key={value} label={value} />
                      ))}
                    </Box>
                  )}
                >
                  {['International', 'Fusion', 'Gourmet', 'Italian', 'Mediterranean', 'Japanese', 'Chinese', 'Thai', 'Mexican', 'American', 'French', 'Indian', 'Vegan', 'Vegetarian', 'Gluten-Free'].map((cuisine) => (
                    <MenuItem key={cuisine} value={cuisine}>
                      {cuisine}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              
              <Box sx={{ mt: 3 }}>
                <Typography id="catering-price-slider" gutterBottom>
                  Maximum Price per Person: ${cateringFilters.maxPrice}
                </Typography>
                <Slider
                  value={cateringFilters.maxPrice}
                  onChange={(e, newValue) => handleCateringFilterChange('maxPrice', newValue)}
                  min={20}
                  max={200}
                  step={5}
                  aria-labelledby="catering-price-slider"
                />
              </Box>
            </Paper>
            
            <Box sx={{ display: 'flex', justifyContent: 'center', mt: 2 }}>
              <Button
                variant="outlined"
                onClick={resetAllFilters}
                sx={{ width: '100%' }}
              >
                Reset All Filters
              </Button>
            </Box>
          </Box>
        );
        
      case 1: // Venue selection
        return (
          <Box sx={{ mt: 4 }}>
            <Typography variant="h6" gutterBottom>
              Choose a Venue
            </Typography>
            
            {availableVenues.length === 0 ? (
              <Alert severity="info" sx={{ mt: 2 }}>
                No venues are available for your selected {eventData.isMultiDay ? 'date range' : 'date'}. 
                Please try a different {eventData.isMultiDay ? 'range' : 'date'}.
              </Alert>
            ) : (
              <Grid container spacing={2} sx={{ mt: 1 }}>
                {availableVenues.map((venue) => (
                  <Grid item xs={12} sm={6} key={venue.id}>
                    <Card 
                      sx={{ 
                        border: eventData.venueId === venue.id ? 2 : 0,
                        borderColor: 'primary.main',
                      }}
                    >
                      <CardActionArea onClick={() => handleServiceSelect('venue', venue.id)}>
                        <ServiceCard service={venue} type="venue" />
                      </CardActionArea>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            )}
          </Box>
        );
        
      case 2: // DJ selection
        return (
          <Box sx={{ mt: 4 }}>
            <Typography variant="h6" gutterBottom>
              Select a DJ
            </Typography>
            
            {availableDJs.length === 0 ? (
              <Alert severity="info" sx={{ mt: 2 }}>
                No DJs are available for your selected {eventData.isMultiDay ? 'date range' : 'date'}. 
                Please try a different {eventData.isMultiDay ? 'range' : 'date'}.
              </Alert>
            ) : (
              <Grid container spacing={2} sx={{ mt: 1 }}>
                {availableDJs.map((dj) => (
                  <Grid item xs={12} sm={6} key={dj.id}>
                    <Card 
                      sx={{ 
                        border: eventData.djId === dj.id ? 2 : 0,
                        borderColor: 'primary.main',
                      }}
                    >
                      <CardActionArea onClick={() => handleServiceSelect('dj', dj.id)}>
                        <ServiceCard service={dj} type="dj" />
                      </CardActionArea>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            )}
          </Box>
        );
        
      case 3: // Catering selection
        return (
          <Box sx={{ mt: 4 }}>
            <Typography variant="h6" gutterBottom>
              Add Catering (Optional)
            </Typography>
            
            {availableCaterers.length === 0 ? (
              <Alert severity="info" sx={{ mt: 2 }}>
                No catering services are available for your selected {eventData.isMultiDay ? 'date range' : 'date'}. 
                Please try a different {eventData.isMultiDay ? 'range' : 'date'}.
              </Alert>
            ) : (
              <Grid container spacing={2} sx={{ mt: 1 }}>
                {availableCaterers.map((catering) => (
                  <Grid item xs={12} sm={6} key={catering.id}>
                    <Card 
                      sx={{ 
                        border: eventData.cateringId === catering.id ? 2 : 0,
                        borderColor: 'primary.main',
                      }}
                    >
                      <CardActionArea onClick={() => handleServiceSelect('catering', catering.id)}>
                        <ServiceCard service={catering} type="catering" />
                      </CardActionArea>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            )}
          </Box>
        );
        
      case 4: // Confirmation
        const selectedVenue = venues.find(v => v.id === eventData.venueId);
        const selectedDJ = djs.find(d => d.id === eventData.djId);
        const selectedCatering = cateringServices.find(c => c.id === eventData.cateringId);
        
        // Calculate number of days for multi-day events
        const numberOfDays = eventData.isMultiDay && eventData.dateRange.start && eventData.dateRange.end
          ? Math.round((eventData.dateRange.end.getTime() - eventData.dateRange.start.getTime()) / (1000 * 60 * 60 * 24)) + 1
          : 1;
        
        // Calculate costs
        const venueCost = selectedVenue ? selectedVenue.price * numberOfDays : 0;
        const djCost = selectedDJ ? selectedDJ.price * numberOfDays : 0;
        const cateringCost = selectedCatering ? selectedCatering.price * eventData.attendees * numberOfDays : 0;
        
        // Calculate tax and service fees (example rates)
        const taxRate = 0.08; // 8% tax
        const serviceFee = 0.15; // 15% service fee
        
        const subtotal = venueCost + djCost + cateringCost;
        const taxAmount = subtotal * taxRate;
        const serviceFeeAmount = subtotal * serviceFee;
        const total = subtotal + taxAmount + serviceFeeAmount;
        
        return (
          <Box sx={{ mt: 4 }}>
            <Typography variant="h6" gutterBottom>
              Event Summary
            </Typography>
            
            <Paper sx={{ p: 3, mt: 2 }}>
              <Typography variant="h5" gutterBottom>
                {eventData.name || 'Untitled Event'}
              </Typography>
              
              <Typography variant="body1" gutterBottom>
                {eventData.isMultiDay && eventData.dateRange.start && eventData.dateRange.end ? (
                  <>
                    Date Range: {format(eventData.dateRange.start, 'MMM d, yyyy')} - {format(eventData.dateRange.end, 'MMM d, yyyy')} ({numberOfDays} days)
                  </>
                ) : (
                  <>
                    Date: {eventData.date ? format(eventData.date, 'MMM d, yyyy') : 'Not selected'}
                  </>
                )}
              </Typography>
              
              <Typography variant="body1" gutterBottom>
                Attendees: {eventData.attendees}
              </Typography>
              
              <Typography variant="body1" gutterBottom>
                Public Event: {eventData.isPublic ? 'Yes' : 'No'}
              </Typography>
              
              <Divider sx={{ my: 2 }} />
              
              <Typography variant="h6" gutterBottom>
                Selected Services:
              </Typography>
              
              {selectedVenue && (
                <Box sx={{ mb: 2 }}>
                  <Typography variant="subtitle1" fontWeight="medium">
                    Venue: {selectedVenue.name}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {selectedVenue.type}  {selectedVenue.style.join(', ')}
                  </Typography>
                  <Typography variant="body2">
                    ${selectedVenue.price.toLocaleString()} per day  {numberOfDays} {numberOfDays > 1 ? 'days' : 'day'}
                  </Typography>
                </Box>
              )}
              
              {selectedDJ && (
                <Box sx={{ mb: 2 }}>
                  <Typography variant="subtitle1" fontWeight="medium">
                    DJ: {selectedDJ.name}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {selectedDJ.genres.join(', ')}
                  </Typography>
                  <Typography variant="body2">
                    ${selectedDJ.price.toLocaleString()} per day  {numberOfDays} {numberOfDays > 1 ? 'days' : 'day'}
                  </Typography>
                </Box>
              )}
              
              {selectedCatering && (
                <Box sx={{ mb: 2 }}>
                  <Typography variant="subtitle1" fontWeight="medium">
                    Catering: {selectedCatering.name}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {selectedCatering.cuisineType.join(', ')}
                  </Typography>
                  <Typography variant="body2">
                    ${selectedCatering.price.toLocaleString()} per person  {eventData.attendees} guests  {numberOfDays} {numberOfDays > 1 ? 'days' : 'day'}
                  </Typography>
                </Box>
              )}
              
              <Divider sx={{ my: 2 }} />
              
              <Typography variant="h6" gutterBottom>
                Price Breakdown:
              </Typography>
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="body1">Venue Total:</Typography>
                <Typography variant="body1">${venueCost.toLocaleString()}</Typography>
              </Box>
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="body1">DJ Total:</Typography>
                <Typography variant="body1">${djCost.toLocaleString()}</Typography>
              </Box>
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="body1">Catering Total:</Typography>
                <Typography variant="body1">${cateringCost.toLocaleString()}</Typography>
              </Box>
              
              <Divider sx={{ my: 1 }} />
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="body1">Subtotal:</Typography>
                <Typography variant="body1">${subtotal.toLocaleString()}</Typography>
              </Box>
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="body1">Tax ({(taxRate * 100).toFixed(0)}%):</Typography>
                <Typography variant="body1">${taxAmount.toLocaleString()}</Typography>
              </Box>
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="body1">Service Fee ({(serviceFee * 100).toFixed(0)}%):</Typography>
                <Typography variant="body1">${serviceFeeAmount.toLocaleString()}</Typography>
              </Box>
              
              <Divider sx={{ my: 1 }} />
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="h6">Total:</Typography>
                <Typography variant="h6" fontWeight="bold">${total.toLocaleString()}</Typography>
              </Box>
              
              <Box sx={{ mt: 3, p: 2, bgcolor: 'primary.light', borderRadius: 1 }}>
                <Typography variant="body2" color="primary.contrastText">
                  A 25% deposit (${(total * 0.25).toLocaleString()}) will be required to confirm your booking. The remaining balance will be due 14 days before your event.
                </Typography>
              </Box>
            </Paper>
          </Box>
        );
        
      default:
        return 'Unknown step';
    }
  };
  
  return (
    <Layout title="Create Event" hideSearch>
      <Container maxWidth="md">
        <Box sx={{ width: '100%', mb: 4 }}>
          <Stepper activeStep={activeStep} alternativeLabel>
            {steps.map((label) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
              </Step>
            ))}
          </Stepper>
          
          {getStepContent(activeStep)}
          
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4 }}>
            <Box>
              <Button
                variant="outlined"
                disabled={activeStep === 0}
                onClick={handleBack}
                startIcon={<ArrowBackIcon />}
                sx={{ mr: 1 }}
              >
                Back
              </Button>
              
              <Button
                variant="outlined"
                onClick={handleSaveDraft}
                startIcon={<SaveIcon />}
              >
                Save Draft
              </Button>
            </Box>
            
            {activeStep === steps.length - 1 ? (
              <Button 
                variant="contained" 
                onClick={handleSubmit}
                disabled={
                  !eventData.venueId || 
                  !eventData.djId || 
                  (eventData.isMultiDay ? 
                    !eventData.dateRange.start || !eventData.dateRange.end : 
                    eventData.isMultiSelect ?
                      eventData.selectedDates.length === 0 :
                      !eventData.date
                  )
                }
              >
                Book Now
              </Button>
            ) : (
              <Button
                variant="contained"
                onClick={handleNext}
                endIcon={<ArrowForwardIcon />}
                disabled={
                  (activeStep === 0 && (
                    !eventData.name || 
                    (eventData.isMultiDay ? 
                      !eventData.dateRange.start || !eventData.dateRange.end : 
                      eventData.isMultiSelect ?
                        eventData.selectedDates.length === 0 :
                        !eventData.date
                    )
                  )) ||
                  (activeStep === 1 && !eventData.venueId) ||
                  (activeStep === 2 && !eventData.djId)
                }
              >
                Next
              </Button>
            )}
          </Box>
        </Box>
        
        {/* Save Draft Dialog */}
        <Dialog open={saveDialogOpen} onClose={() => setSaveDialogOpen(false)}>
          <DialogTitle>Save Event Draft</DialogTitle>
          <DialogContent>
            <DialogContentText>
              Give your draft a name so you can easily find it later.
            </DialogContentText>
            <TextField
              autoFocus
              margin="dense"
              label="Draft Name"
              fullWidth
              variant="outlined"
              value={draftName || eventData.name || 'Untitled Event'}
              onChange={(e) => setDraftName(e.target.value)}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setSaveDialogOpen(false)}>Cancel</Button>
            <Button onClick={confirmSaveDraft} variant="contained">Save</Button>
          </DialogActions>
        </Dialog>
        
        {/* Snackbar for notifications */}
        <Snackbar
          open={snackbarOpen}
          autoHideDuration={6000}
          onClose={handleSnackbarClose}
          message={snackbarMessage}
          action={
            <IconButton
              size="small"
              color="inherit"
              onClick={handleSnackbarClose}
            >
              <CloseIcon fontSize="small" />
            </IconButton>
          }
        />
      </Container>
    </Layout>
  );
};

export default CreateEventPage; 